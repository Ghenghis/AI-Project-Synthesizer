"""
Tests for discovery.firecrawl_enhanced.
Generated by rapid_test_generator.py
"""

import os
import pytest
import time
from unittest.mock import MagicMock, patch

os.environ["APP_ENV"] = "testing"

try:
    from src.discovery.firecrawl_enhanced import (
        CacheStrategy,
        RateLimitStrategy,
        ContentPriority
    )
    IMPORTS_AVAILABLE = True
except ImportError as e:
    print(f"Import error for discovery.firecrawl_enhanced: {e}")
    IMPORTS_AVAILABLE = False


class TestCacheStrategy:
    """Test CacheStrategy."""

    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    def test_cache_strategy_values(self):
        """Should have correct CacheStrategy values."""
        assert CacheStrategy.NONE.value == "none"
        assert CacheStrategy.MEMORY.value == "memory"
        assert CacheStrategy.DISK.value == "disk"
        assert CacheStrategy.HYBRID.value == "hybrid"


class TestRateLimitStrategy:
    """Test RateLimitStrategy."""

    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    def test_rate_limit_strategy_values(self):
        """Should have correct RateLimitStrategy values."""
        assert RateLimitStrategy.FIXED.value == "fixed"
        assert RateLimitStrategy.EXPONENTIAL_BACKOFF.value == "exponential"
        assert RateLimitStrategy.ADAPTIVE.value == "adaptive"
        assert RateLimitStrategy.TOKEN_BUCKET.value == "token_bucket"


class TestContentPriority:
    """Test ContentPriority."""

    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    def test_content_priority_values(self):
        """Should have correct ContentPriority values."""
        assert ContentPriority.LOW.value == 1
        assert ContentPriority.NORMAL.value == 2
        assert ContentPriority.HIGH.value == 3
        assert ContentPriority.CRITICAL.value == 4


class TestCacheEntry:
    """Test CacheEntry dataclass."""
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    def test_cache_entry_creation(self):
        """Should create CacheEntry with all fields."""
        from src.discovery.firecrawl_enhanced import CacheEntry
        from src.discovery.firecrawl_client import ScrapedContent, FirecrawlFormat
        from datetime import datetime, timedelta
        
        content = ScrapedContent(
            url="https://example.com",
            title="Test Page",
            description="Test description",
            content="Test content",
            format=FirecrawlFormat.MARKDOWN,
            timestamp=datetime.now(),
            links=[],
            images=[],
            metadata={}
        )
        
        entry = CacheEntry(
            key="test_key",
            content=content,
            timestamp=datetime.now(),
            ttl=timedelta(hours=1)
        )
        
        assert entry.key == "test_key"
        assert entry.content == content
        assert entry.hits == 0
        assert not entry.is_expired
        assert entry.age_seconds >= 0
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    def test_cache_entry_expired(self):
        """Should correctly identify expired entries."""
        from src.discovery.firecrawl_enhanced import CacheEntry
        from src.discovery.firecrawl_client import ScrapedContent, FirecrawlFormat
        from datetime import datetime, timedelta
        
        content = ScrapedContent(
            url="https://example.com",
            title="Test Page",
            description="Test description",
            content="Test content",
            format=FirecrawlFormat.MARKDOWN,
            timestamp=datetime.now(),
            links=[],
            images=[],
            metadata={}
        )
        
        entry = CacheEntry(
            key="test_key",
            content=content,
            timestamp=datetime.now() - timedelta(hours=2),
            ttl=timedelta(hours=1)
        )
        
        assert entry.is_expired
        assert entry.age_seconds >= 3600


class TestRateLimitConfig:
    """Test RateLimitConfig dataclass."""
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    def test_rate_limit_config_defaults(self):
        """Should create RateLimitConfig with default values."""
        from src.discovery.firecrawl_enhanced import RateLimitConfig, RateLimitStrategy
        
        config = RateLimitConfig()
        
        assert config.requests_per_second == 1.0
        assert config.burst_limit == 10
        assert config.strategy == RateLimitStrategy.ADAPTIVE
        assert config.max_retries == 3
        assert config.backoff_factor == 2.0
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    def test_rate_limit_config_custom(self):
        """Should create RateLimitConfig with custom values."""
        from src.discovery.firecrawl_enhanced import RateLimitConfig, RateLimitStrategy
        
        config = RateLimitConfig(
            requests_per_second=5.0,
            burst_limit=20,
            strategy=RateLimitStrategy.TOKEN_BUCKET,
            max_retries=5,
            backoff_factor=1.5
        )
        
        assert config.requests_per_second == 5.0
        assert config.burst_limit == 20
        assert config.strategy == RateLimitStrategy.TOKEN_BUCKET
        assert config.max_retries == 5
        assert config.backoff_factor == 1.5


class TestContentExtractionConfig:
    """Test ContentExtractionConfig dataclass."""
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    def test_content_extraction_config_defaults(self):
        """Should create ContentExtractionConfig with default values."""
        from src.discovery.firecrawl_enhanced import ContentExtractionConfig
        
        config = ContentExtractionConfig()
        
        assert config.extract_images is True
        assert config.extract_tables is True
        assert config.extract_code is True
        assert config.extract_links is True


class TestFirecrawlEnhanced:
    """Test FirecrawlEnhanced client."""
    
    @pytest.fixture(autouse=True)
    def setup_mocks(self):
        """Setup common mocks for all tests."""
        with patch('src.discovery.firecrawl_enhanced.LiteLLMRouter') as mock_llm, \
             patch('src.discovery.firecrawl_enhanced.tiktoken.get_encoding') as mock_tokenizer:
            mock_llm.return_value = MagicMock()
            mock_tokenizer.return_value = MagicMock()
            self.mock_llm = mock_llm
            self.mock_tokenizer = mock_tokenizer
            yield
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    def test_firecrawl_enhanced_init(self):
        """Should initialize with default settings."""
        from src.discovery.firecrawl_enhanced import FirecrawlEnhanced, CacheStrategy
        
        client = FirecrawlEnhanced(api_key="test_key")
        
        assert client.cache_strategy == CacheStrategy.HYBRID
        assert client.cache_dir.exists()
        assert client._memory_cache == {}
        assert client._memory_cache_size == 100
        assert client._db_path.exists()
        assert client.llm_router is not None
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    def test_firecrawl_enhanced_init_custom_cache(self):
        """Should initialize with custom cache settings."""
        from src.discovery.firecrawl_enhanced import FirecrawlEnhanced, CacheStrategy, RateLimitConfig, RateLimitStrategy
        import shutil
        from pathlib import Path
        
        temp_dir = Path("temp_cache")
        rate_config = RateLimitConfig(
            requests_per_second=5.0,
            strategy=RateLimitStrategy.TOKEN_BUCKET
        )
        
        try:
            client = FirecrawlEnhanced(
                api_key="test_key",
                cache_strategy=CacheStrategy.MEMORY,
                cache_dir=temp_dir,
                rate_limit_config=rate_config
            )
            
            assert client.cache_strategy == CacheStrategy.MEMORY
            assert client.cache_dir == temp_dir
            assert client.rate_limit_config.requests_per_second == 5.0
            assert client.rate_limit_config.strategy == RateLimitStrategy.TOKEN_BUCKET
        finally:
            if temp_dir.exists():
                shutil.rmtree(temp_dir)
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    async def test_get_from_cache_none_strategy(self):
        """Should return None when cache strategy is NONE."""
        from src.discovery.firecrawl_enhanced import FirecrawlEnhanced, CacheStrategy
        
        client = FirecrawlEnhanced(api_key="test_key", cache_strategy=CacheStrategy.NONE)
        
        result = await client._get_from_cache("test_key")
        
        assert result is None
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    async def test_get_from_memory_cache(self):
        """Should retrieve from memory cache."""
        from src.discovery.firecrawl_enhanced import FirecrawlEnhanced, CacheStrategy, CacheEntry
        from src.discovery.firecrawl_client import ScrapedContent, FirecrawlFormat
        from datetime import datetime, timedelta
        
        client = FirecrawlEnhanced(api_key="test_key", cache_strategy=CacheStrategy.MEMORY)
        
        content = ScrapedContent(
            url="https://example.com",
            title="Test",
            description="Test description",
            content="Test content",
            format=FirecrawlFormat.MARKDOWN,
            timestamp=datetime.now(),
            links=[],
            images=[],
            metadata={}
        )
        
        entry = CacheEntry(
            key="test_key",
            content=content,
            timestamp=datetime.now(),
            ttl=timedelta(hours=1)
        )
        
        client._memory_cache["test_key"] = entry
        
        result = await client._get_from_cache("test_key")
        
        assert result == content
        assert entry.hits == 1
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    async def test_get_from_memory_cache_expired(self):
        """Should remove expired entries from memory cache."""
        from src.discovery.firecrawl_enhanced import FirecrawlEnhanced, CacheStrategy, CacheEntry
        from src.discovery.firecrawl_client import ScrapedContent, FirecrawlFormat
        from datetime import datetime, timedelta
        
        client = FirecrawlEnhanced(api_key="test_key", cache_strategy=CacheStrategy.MEMORY)
        
        content = ScrapedContent(
            url="https://example.com",
            title="Test",
            description="Test description",
            content="Test content",
            format=FirecrawlFormat.MARKDOWN,
            timestamp=datetime.now(),
            links=[],
            images=[],
            metadata={}
        )
        
        entry = CacheEntry(
            key="test_key",
            content=content,
            timestamp=datetime.now() - timedelta(hours=2),
            ttl=timedelta(hours=1)
        )
        
        client._memory_cache["test_key"] = entry
        
        result = await client._get_from_cache("test_key")
        
        assert result is None
        assert "test_key" not in client._memory_cache
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    def test_init_disk_cache(self):
        """Should initialize disk cache database."""
        from src.discovery.firecrawl_enhanced import FirecrawlEnhanced
        import sqlite3
        
        client = FirecrawlEnhanced(api_key="test_key")
        
        # Verify database was created
        conn = sqlite3.connect(str(client._db_path))
        cursor = conn.execute(
            "SELECT name FROM sqlite_master WHERE type='table' AND name='cache'"
        )
        table_exists = cursor.fetchone() is not None
        conn.close()
        
        assert table_exists
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    def test_cache_key_generation(self):
        """Should generate consistent cache keys."""
        from src.discovery.firecrawl_enhanced import FirecrawlEnhanced
        
        client = FirecrawlEnhanced(api_key="test_key")
        
        # Test with same URL and options
        key1 = client._get_cache_key("https://example.com", {})
        key2 = client._get_cache_key("https://example.com", {})
        
        assert key1 == key2
        
        # Test with different URLs
        key3 = client._get_cache_key("https://example.com/page2", {})
        assert key1 != key3
        
        # Test with different only_main_content option
        key4 = client._get_cache_key("https://example.com", {"only_main_content": False})
        assert key1 != key4
        
        # Test with formats array
        from src.discovery.firecrawl_client import FirecrawlFormat
        key5 = client._get_cache_key("https://example.com", {"formats": [FirecrawlFormat.HTML]})
        assert key1 != key5


class TestRateLimiter:
    """Test RateLimiter class."""
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    def test_rate_limiter_init(self):
        """Should initialize with default values."""
        from src.discovery.firecrawl_enhanced import RateLimiter, RateLimitConfig, RateLimitStrategy
        
        config = RateLimitConfig(requests_per_second=2.0, burst_limit=5)
        limiter = RateLimiter(config)
        
        assert limiter.config == config
        assert limiter._tokens == 5
        assert limiter._failures == 0
        assert limiter._last_request_time == 0
        assert limiter._adaptive_delay == 0.5
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    async def test_fixed_wait_strategy(self):
        """Should wait fixed delay between requests."""
        from src.discovery.firecrawl_enhanced import RateLimiter, RateLimitConfig, RateLimitStrategy
        
        config = RateLimitConfig(
            requests_per_second=10.0,
            strategy=RateLimitStrategy.FIXED
        )
        limiter = RateLimiter(config)
        
        start_time = time.time()
        await limiter.acquire()
        await limiter.acquire()
        elapsed = time.time() - start_time
        
        # Should wait at least 0.1 seconds between requests
        assert elapsed >= 0.1
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    async def test_exponential_backoff_strategy(self):
        """Should use exponential backoff after failures."""
        from src.discovery.firecrawl_enhanced import RateLimiter, RateLimitConfig, RateLimitStrategy
        
        config = RateLimitConfig(
            requests_per_second=10.0,
            strategy=RateLimitStrategy.EXPONENTIAL_BACKOFF,
            backoff_factor=2.0
        )
        limiter = RateLimiter(config)
        
        # Record failures
        limiter.record_failure()
        limiter.record_failure()
        
        start_time = time.time()
        await limiter.acquire()
        elapsed = time.time() - start_time
        
        # Should wait 2^2 = 4 seconds (capped at 60)
        assert elapsed >= 3.9  # Allow small timing variance
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    async def test_adaptive_strategy(self):
        """Should adapt delay based on failures."""
        from src.discovery.firecrawl_enhanced import RateLimiter, RateLimitConfig, RateLimitStrategy
        
        config = RateLimitConfig(
            requests_per_second=10.0,
            strategy=RateLimitStrategy.ADAPTIVE
        )
        limiter = RateLimiter(config)
        
        # Record failure to increase delay
        limiter.record_failure()
        
        start_time = time.time()
        await limiter.acquire()
        elapsed = time.time() - start_time
        
        # Should wait longer than base delay
        assert elapsed >= 0.075  # Base 0.1 * 1.5 = 0.15, but with bounds
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    async def test_token_bucket_strategy(self):
        """Should use token bucket algorithm."""
        from src.discovery.firecrawl_enhanced import RateLimiter, RateLimitConfig, RateLimitStrategy
        
        config = RateLimitConfig(
            requests_per_second=10.0,
            burst_limit=5,
            strategy=RateLimitStrategy.TOKEN_BUCKET
        )
        limiter = RateLimiter(config)
        
        # Should be able to make burst_limit requests immediately
        for _ in range(5):
            await limiter.acquire()
        
        # Next request should wait for token refill
        start_time = time.time()
        await limiter.acquire()
        elapsed = time.time() - start_time
        
        assert elapsed >= 0.09  # Should wait for token refill
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    def test_record_success(self):
        """Should reset failures on success."""
        from src.discovery.firecrawl_enhanced import RateLimiter, RateLimitConfig
        
        config = RateLimitConfig()
        limiter = RateLimiter(config)
        
        limiter.record_failure()
        limiter.record_failure()
        assert limiter._failures == 2
        
        limiter.record_success()
        assert limiter._failures == 0
    
    @pytest.mark.skipif(not IMPORTS_AVAILABLE, reason="Module not available")
    def test_record_failure(self):
        """Should increment failures up to max_retries."""
        from src.discovery.firecrawl_enhanced import RateLimiter, RateLimitConfig
        
        config = RateLimitConfig(max_retries=3)
        limiter = RateLimiter(config)
        
        limiter.record_failure()
        limiter.record_failure()
        limiter.record_failure()
        limiter.record_failure()  # Should cap at max_retries
        
        assert limiter._failures == 3



if __name__ == '__main__':
    pytest.main([__file__, '-v'])
